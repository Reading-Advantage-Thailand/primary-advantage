---
globs: prisma/**/*,server/**/*,**/models/*,**/controllers/*
description: Prisma database patterns and data access conventions
---

# Prisma Database Patterns & Data Access

## Database Schema Overview

The application uses PostgreSQL with Prisma ORM, featuring:

- **Multi-tenant architecture** with School-based organization
- **Role-based access control** with flexible user roles
- **Educational content management** (Articles, Questions, Flashcards)
- **Progress tracking** with XP system and activity logs
- **Classroom management** with teacher-student relationships

## Key Models & Relationships

### User Management

- `User` - Core user entity with XP, CEFR level, and school association
- `UserRole` - Many-to-many relationship for flexible role assignment
- `Role` - Defines user permissions (STUDENT, TEACHER, ADMIN, SYSTEM)
- `School` - Multi-tenant organization with license management
- `License` - School licensing with user limits and expiry

### Educational Content

- `Article` - Reading content with CEFR levels and translations
- `MultipleChoiceQuestion`, `ShortAnswerQuestion`, `LongAnswerQuestion` - Assessment content
- `FlashcardDeck` and `FlashcardCard` - Spaced repetition system using ts-fsrs
- `UserActivity` and `XPLogs` - Progress and engagement tracking

### Classroom Management

- `Classroom` - Teacher-managed learning groups
- `ClassroomStudent` and `ClassroomTeachers` - Many-to-many relationships

## Prisma Patterns

### Model Controllers

Organize database operations in `server/controllers/`:

```typescript
// server/controllers/userController.ts
import { prisma } from "@/lib/prisma";

export async function fetchUserActivity(userId: string) {
  return await prisma.userActivity.findMany({
    where: { userId },
    include: {
      user: {
        select: { name: true, email: true },
      },
    },
    orderBy: { createdAt: "desc" },
  });
}
```

### Model Services

Create reusable functions in `server/models/`:

```typescript
// server/models/userModel.ts
export async function getUserByEmail(email: string) {
  return await prisma.user.findUnique({
    where: { email },
    include: {
      roles: {
        include: {
          role: true,
        },
      },
    },
  });
}
```

## Query Patterns

### Efficient Queries

- Use `select` to limit returned fields
- Use `include` for necessary relations only
- Implement pagination for large datasets
- Use proper indexing (defined in schema)

```typescript
// Good: Selective querying
const articles = await prisma.article.findMany({
  select: {
    id: true,
    title: true,
    summary: true,
    cefrLevel: true,
    rating: true,
  },
  where: { cefrLevel: userLevel },
  take: 10,
  skip: page * 10,
});
```

### Complex Queries

```typescript
// Multi-table queries with proper filtering
const classroomData = await prisma.classroom.findUnique({
  where: { id: classroomId },
  include: {
    students: {
      include: {
        student: {
          select: {
            id: true,
            name: true,
            email: true,
            cefrLevel: true,
            xp: true,
            level: true,
          },
        },
      },
    },
    teachers: {
      include: {
        user: {
          select: { name: true, email: true },
        },
      },
    },
  },
});
```

## Transaction Patterns

Use transactions for data consistency:

```typescript
await prisma.$transaction(async (tx) => {
  // Update user XP
  await tx.user.update({
    where: { id: userId },
    data: { xp: { increment: xpEarned } },
  });

  // Log XP gain
  await tx.xPLogs.create({
    data: {
      userId,
      xpEarned,
      activityType: "ARTICLE_READ",
      activityId: articleId,
    },
  });

  // Update activity completion
  await tx.userActivity.update({
    where: { id: activityId },
    data: { completed: true },
  });
});
```

## Schema Management

### Migration Best Practices

- Always review generated migrations before applying
- Use descriptive migration names
- Test migrations on development data first
- Keep migrations focused on single changes

### Schema Conventions

- Use `@map()` for database column names (snake_case)
- Use `@unique` and `@@unique` for proper constraints
- Define proper relations with `onDelete` cascades
- Use enums for fixed value sets

## Data Validation

### Input Validation

```typescript
import { z } from "zod";

const createArticleSchema = z.object({
  title: z.string().min(1).max(200),
  passage: z.string().min(1),
  cefrLevel: z.enum([
    "A1-",
    "A1",
    "A1+",
    "A2-",
    "A2",
    "A2+",
    "B1-",
    "B1",
    "B1+",
  ]),
  genre: z.string(),
  subGenre: z.string(),
});
```

### Database Constraints

- Use Prisma schema constraints for data integrity
- Implement proper foreign key relationships
- Use database-level defaults where appropriate

## Performance Considerations

- Use database indexes for frequently queried fields
- Implement connection pooling in production
- Use read replicas for heavy read operations
- Monitor query performance and optimize slow queries
- Use appropriate data types for optimal storage
