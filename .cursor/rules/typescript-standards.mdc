---
globs: *.ts,*.tsx
description: TypeScript coding standards and type safety guidelines
---

# TypeScript Standards & Type Safety

## Type Definition Patterns

### Interface vs Type Aliases

Use interfaces for object shapes that might be extended:

```typescript
interface User {
  id: string;
  name: string;
  email: string;
  role: UserRole;
}

interface Student extends User {
  cefrLevel: string;
  xp: number;
  level: number;
}
```

Use type aliases for unions, primitives, and computed types:

```typescript
type UserRole = "STUDENT" | "TEACHER" | "ADMIN" | "SYSTEM";
type FlashcardType = "VOCABULARY" | "SENTENCE";
type GameDifficulty = "easy" | "medium" | "hard";
type LocaleCode = "en" | "th" | "vi" | "cn" | "tw";
```

### Component Props Typing

```typescript
interface ComponentProps {
  // Required props first
  title: string;
  data: Article[];
  onSubmit: (data: FormData) => void;

  // Optional props
  className?: string;
  disabled?: boolean;
  children?: React.ReactNode;

  // Event handlers with proper typing
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
  onChange?: (value: string) => void;
}

// Generic components
interface TableProps<T> {
  data: T[];
  columns: Column<T>[];
  onRowClick?: (row: T) => void;
}
```

## API Response Typing

### Consistent API Response Structure

```typescript
interface ApiResponse<T = unknown> {
  data?: T;
  error?: string;
  message?: string;
  status: number;
}

interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}
```

### API Route Parameter Typing

```typescript
// Route parameters
interface RouteParams {
  locale: string;
  id?: string;
  articleId?: string;
}

// Search parameters
interface SearchParams {
  page?: string;
  limit?: string;
  search?: string;
  filter?: string;
}

// API route handler typing
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<RouteParams> },
): Promise<NextResponse<ApiResponse<Article[]>>> {
  const { id } = await params;
  // Implementation
}
```

## Database Model Typing

### Prisma Generated Types

Use Prisma generated types as base, extend when needed:

```typescript
import type { User, Article, Classroom } from "@prisma/client";

// Extended types with relations
type UserWithRoles = User & {
  roles: Array<{
    role: {
      name: string;
    };
  }>;
};

type ArticleWithQuestions = Article & {
  multipleChoiceQuestions: MultipleChoiceQuestion[];
  shortAnswerQuestions: ShortAnswerQuestion[];
  longAnswerQuestions: LongAnswerQuestion[];
};
```

### Form Data Typing

```typescript
import { z } from "zod";

const createArticleSchema = z.object({
  title: z.string().min(1).max(200),
  passage: z.string().min(1),
  cefrLevel: z.enum([
    "A1-",
    "A1",
    "A1+",
    "A2-",
    "A2",
    "A2+",
    "B1-",
    "B1",
    "B1+",
  ]),
  genre: z.string(),
  subGenre: z.string(),
  type: z.enum(["story", "article", "news"]),
});

type CreateArticleInput = z.infer<typeof createArticleSchema>;
```

## Utility Types

### Common Utility Type Patterns

```typescript
// Pick specific fields
type UserSummary = Pick<User, "id" | "name" | "email" | "xp">;

// Make certain fields optional
type PartialUser = Partial<Pick<User, "name" | "email">>;

// Exclude certain fields
type PublicUser = Omit<User, "password" | "emailVerified">;

// Record types for mappings
type LocalizedContent = Record<LocaleCode, string>;
type UserStats = Record<string, number>;
```

### Game and Activity Types

```typescript
interface GameData<T = unknown> {
  id: string;
  difficulty: GameDifficulty;
  data: T;
  metadata?: Record<string, unknown>;
}

interface GameResult {
  score: number;
  totalQuestions: number;
  timeSpent: number;
  completed: boolean;
  answers: Array<{
    questionId: string;
    userAnswer: string;
    correctAnswer: string;
    isCorrect: boolean;
  }>;
}

interface ActivityProgress {
  current: number;
  total: number;
  percentage: number;
  completed: boolean;
}
```

## Error Handling Types

### Structured Error Types

```typescript
interface AppError {
  code: string;
  message: string;
  details?: Record<string, unknown>;
  statusCode: number;
}

type ValidationError = AppError & {
  code: "VALIDATION_ERROR";
  field: string;
  value: unknown;
};

type AuthError = AppError & {
  code: "AUTH_ERROR" | "FORBIDDEN" | "UNAUTHORIZED";
};
```

### Result Pattern for Error Handling

```typescript
type Result<T, E = AppError> =
  | { success: true; data: T }
  | { success: false; error: E };

async function fetchUser(id: string): Promise<Result<User>> {
  try {
    const user = await getUserById(id);
    return { success: true, data: user };
  } catch (error) {
    return {
      success: false,
      error: {
        code: "USER_NOT_FOUND",
        message: "User not found",
        statusCode: 404,
      },
    };
  }
}
```

## Type Guards and Validation

### Type Guards

```typescript
function isStudent(user: User): user is Student {
  return user.roles.some((role) => role.role.name === "STUDENT");
}

function hasRole(user: User, roleName: string): boolean {
  return user.roles.some((role) => role.role.name === roleName);
}

function isValidLocale(locale: string): locale is LocaleCode {
  return ["en", "th", "vi", "cn", "tw"].includes(locale);
}
```

### Runtime Validation

```typescript
import { z } from "zod";

const userSchema = z.object({
  id: z.string().cuid(),
  email: z.string().email(),
  name: z.string().min(1),
  role: z.enum(["STUDENT", "TEACHER", "ADMIN", "SYSTEM"]),
});

function validateUser(data: unknown): User {
  return userSchema.parse(data);
}
```

## Best Practices

### Type Safety Guidelines

- Always type function parameters and return values
- Use strict TypeScript configuration (`strict: true`)
- Prefer interfaces for object shapes, types for unions
- Use generic types for reusable components and functions
- Implement proper error handling with typed errors

### Code Organization

- Define types close to where they're used
- Use barrel exports for commonly used types
- Group related types in dedicated files
- Use consistent naming conventions (PascalCase for types/interfaces)

### Performance Considerations

- Use `const assertions` for immutable data
- Implement proper tree-shaking with type-only imports
- Use discriminated unions for complex state management
- Leverage TypeScript's control flow analysis

### Integration with External Libraries

- Always install and use `@types/` packages when available
- Create custom type definitions for untyped libraries
- Use module augmentation to extend third-party types when needed
- Maintain type compatibility with Prisma generated types
