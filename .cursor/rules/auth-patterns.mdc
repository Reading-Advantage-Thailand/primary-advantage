---
globs: lib/auth.ts,lib/session.ts,app/auth/**/*,components/auth/**/*
description: Authentication and authorization patterns using NextAuth.js
---

# Authentication & Authorization Patterns

## Authentication System Overview

The application uses **NextAuth.js v5** with multiple authentication strategies:

- **Google OAuth** for social login
- **Credentials** for email/password authentication with role-based access
- **Session management** with JWT strategy
- **Role-based authorization** with flexible user roles

## Authentication Configuration

### NextAuth.js Setup

Reference: [lib/auth.ts](mdc:lib/auth.ts)

Key configuration patterns:

```typescript
export const { handlers, signIn, signOut, auth } = NextAuth({
  trustHost: true,
  adapter: PrismaAdapter(prisma),
  providers: [
    Credentials({
      authorize: async (credentials): Promise<User | null> => {
        // Custom validation logic with role-based access
        const { email, password, type } =
          await signInSchema.parseAsync(credentials);
        const user = await getUserByEmail(email);

        // Different auth flows for students vs other users
        if (type === "student") {
          return userData; // No password required
        }

        if (type === "other") {
          const isPasswordValid = await bcrypt.compare(password, user.password);
          if (isPasswordValid) return userData;
        }

        return null;
      },
    }),
    Google({
      clientId: process.env.AUTH_GOOGLE_ID,
      clientSecret: process.env.AUTH_GOOGLE_SECRET,
    }),
  ],
  session: { strategy: "jwt" },
  callbacks: {
    async jwt({ token, user, account }) {
      // Extend JWT with user role and profile data
    },
    async session({ session, token }) {
      // Map JWT data to session
    },
  },
});
```

## Session Management

### Server-Side Session Access

```typescript
import { auth } from "@/lib/auth";

// In Server Components and API routes
export default async function Page() {
  const session = await auth();
  if (!session) redirect("/auth/signin");

  // Access user data
  const { user } = session;
  console.log(user.role, user.xp, user.level);
}
```

### Client-Side Session Access

```typescript
"use client";
import { useSession } from "next-auth/react";

export function ClientComponent() {
  const { data: session, status } = useSession();

  if (status === "loading") return <Loading />;
  if (!session) return <SignInPrompt />;

  return <div>Welcome {session.user.name}</div>;
}
```

### Current User Utility

Use `currentUser()` from `@/lib/session` for consistent user access:

```typescript
import { currentUser } from "@/lib/session";

export async function protectedAction() {
  const user = await currentUser();
  if (!user) throw new Error("Unauthorized");

  // Use user data safely
  return await performAction(user.id);
}
```

## Authorization Patterns

### Role-Based Access Control

The system supports multiple roles with hierarchical permissions:

- **STUDENT**: Basic reading and learning activities
- **TEACHER**: Classroom management, student progress
- **ADMIN**: School administration, user management
- **SYSTEM**: Platform-wide administration

### Route Protection

```typescript
// Layout-level protection
export default async function ProtectedLayout({ children }) {
  const session = await auth();
  if (!session) redirect("/auth/signin");

  // Role-specific redirects
  const userRole = session.user.role;
  if (userRole === "STUDENT" && !isStudentRoute(pathname)) {
    redirect("/student");
  }

  return <>{children}</>;
}

// Page-level protection
export default async function AdminPage() {
  const user = await currentUser();
  if (!user || !["ADMIN", "SYSTEM"].includes(user.role)) {
    return <Unauthorized />;
  }

  return <AdminDashboard />;
}
```

### API Route Authorization

```typescript
export async function GET(request: NextRequest) {
  const user = await currentUser();

  if (!user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  // Role-based access control
  if (user.role !== "TEACHER" && user.role !== "SYSTEM") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  // Resource ownership check
  if (user.id !== resourceOwnerId && !["ADMIN", "SYSTEM"].includes(user.role)) {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  return NextResponse.json(data);
}
```

## Authentication Forms

### Sign-in Form Patterns

Follow established patterns in `components/auth/`:

```typescript
"use client";
import { signIn } from "next-auth/react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";

export function SignInForm() {
  const form = useForm({
    resolver: zodResolver(signInSchema)
  });

  const onSubmit = async (data) => {
    const result = await signIn("credentials", {
      ...data,
      redirect: false
    });

    if (result?.error) {
      // Handle authentication errors
    } else {
      // Redirect based on user role
      router.push(getRoleBasedRedirect(user.role));
    }
  };

  return (
    <Form {...form}>
      {/* Form implementation */}
    </Form>
  );
}
```

### Role-Based Authentication

```typescript
// Student authentication (simplified)
const studentSignIn = await signIn("credentials", {
  email: studentEmail,
  password: "", // No password required
  type: "student",
});

// Teacher/Admin authentication (with password)
const teacherSignIn = await signIn("credentials", {
  email: teacherEmail,
  password: hashedPassword,
  type: "other",
});
```

## Session Provider Setup

### Root Layout Integration

```typescript
import { SessionProvider } from "next-auth/react";

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <SessionProvider>
          {children}
        </SessionProvider>
      </body>
    </html>
  );
}
```

## Security Best Practices

### Environment Variables

```bash
AUTH_SECRET=your-secret-key
AUTH_GOOGLE_ID=google-oauth-client-id
AUTH_GOOGLE_SECRET=google-oauth-client-secret
NEXTAUTH_URL=your-domain.com
```

### Password Security

- Use `bcryptjs` for password hashing
- Implement proper password validation
- Support password reset flows

### Session Security

- Use secure JWT tokens
- Implement proper session expiration
- Handle session refresh appropriately
