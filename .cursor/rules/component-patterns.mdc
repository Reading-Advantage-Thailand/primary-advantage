---
globs: components/**/*,*.tsx
description: React component patterns and UI standards
---

# React Component Patterns & UI Standards

## Component Organization

### Directory Structure

```
components/
├── ui/           # Reusable UI primitives (Radix UI based)
├── shared/       # Shared layout components
├── nav/          # Navigation components
├── auth/         # Authentication forms
├── dashboard/    # Dashboard-specific components
├── teacher/      # Teacher-specific components
├── admin/        # Admin-specific components
├── articles/     # Article-related components
├── flashcards/   # Flashcard system components
├── practice/     # Learning game components
└── feature/      # Feature-specific components
```

## Component Patterns

### Standard Component Structure

```typescript
"use client"; // Only when needed for interactivity

import React from "react";
import { useTranslations } from "next-intl";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

interface ComponentProps {
  className?: string;
  children?: React.ReactNode;
  // Define specific props with proper types
}

export function Component({
  className,
  children,
  ...props
}: ComponentProps) {
  const t = useTranslations("Namespace");

  return (
    <div className={cn("base-classes", className)} {...props}>
      {children}
    </div>
  );
}
```

### Form Components

- Use `react-hook-form` with Zod validation
- Implement proper error handling and loading states
- Follow established form patterns:

```typescript
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";

const formSchema = z.object({
  field: z.string().min(1, "Field is required"),
});

export function FormComponent() {
  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
  });

  // Implementation with proper form handling
}
```

### Game/Interactive Components

- Use proper state management with `useState` and `useEffect`
- Implement loading states and error boundaries
- Follow established game patterns for consistency:

```typescript
interface GameData {
  id: string;
  difficulty: "easy" | "medium" | "hard";
  // Game-specific properties
}

interface GameProps {
  data: GameData[];
  onComplete: (results: GameResults) => void;
  onBack: () => void;
}

export function GameComponent({ data, onComplete, onBack }: GameProps) {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [isLoading, setIsLoading] = useState(false);

  // Game logic implementation
}
```

## UI Component Standards

### Styling Guidelines

- Use Tailwind CSS classes with `cn()` utility for conditional styling
- Follow the established design system with Radix UI components
- Implement responsive design with mobile-first approach
- Use consistent spacing, colors, and typography

### Icon Usage

- Use `lucide-react` icons consistently
- Import only needed icons to optimize bundle size
- Use semantic icon names that match functionality

### Accessibility

- Include proper ARIA labels and roles
- Ensure keyboard navigation support
- Use semantic HTML elements
- Implement focus management for interactive components

## Internationalization in Components

- Use `useTranslations()` hook for all user-facing text
- Organize translation keys by component namespace
- Support RTL languages where applicable
- Handle pluralization and number formatting properly

## Performance Considerations

- Use `React.memo()` for expensive components
- Implement proper key props for lists
- Use `useCallback` and `useMemo` judiciously
- Lazy load heavy components when appropriate

## State Management

- Use local state (`useState`) for component-specific data
- Use Zustand for complex shared state
- Leverage server state through proper data fetching
- Avoid prop drilling with context when necessary
